= Jeu de cartes Zheng Fen

.Composition du groupe (Ã  complÃ©ter)
--
* NOM1, PrÃ©nom1, no_Ã©tudiant, login_github
* NOM2, PrÃ©nom2, no_Ã©tudiant, login_github
* NOM3, PrÃ©nom3, no_Ã©tudiant, login_github
* NOM4, PrÃ©nom4, no_Ã©tudiant, login_github
--

L'objet de ce mini-projet est de dÃ©velopper le jeu de carte https://boardgamegeek.com/boardgame/70451/zheng-fen[zheng-fen] qui doit fonctionner en mode ligne de commande.
La rÃ¨gle du jeu est disponible dans la https://boardgamegeek.com/filepage/205610/regles-en-francais-plus-aide-de-jeu[section _Files_] du site prÃ©cÃ©dent.
Ce document est une traduction franÃ§aise de la page https://www.pagat.com/climbing/zhengfen.html[Zheng Fen (æŒ£åˆ†)].
Ce jeu comporte de nombreuses variantes (https://www.pagat.com/climbing/doudizhu.html[Dou Dizhu (æ–—åœ°ä¸»)], https://boardgamegeek.com/boardgame/215/tichu[Tichu]).

[IMPORTANT]
====
* Vous devrez respecter les contraintes techniques et fonctionnelles mentionnÃ©es ci-dessous.
* L'usage de bibliothÃ¨ques tierces est autorisÃ©.
* Ce qui n'est pas imposÃ© par le sujet est laissÃ© Ã  votre libre interprÃ©tation.
====

== Contraintes techniques
* Ce mini-projet est Ã  rÃ©aliser en Java par groupe de 4 Ã©tudiants (3 ou 5 possibles avec accord de l'enseignant).
  - les Ã©tudiants doivent coopÃ©rer Ã  travers un mÃªme git (celui crÃ©Ã© par _github classroom_).
  Les contributions des participants (_commits_) doivent Ãªtre Ã©quilibrÃ©es.
* Il devra comporter une documentation dans ce fichier (cf. ci-dessous).
  - La documentation devra dÃ©crire l'usage de l'application (_manuel utilisateur_) ainsi que la conception du jeu (_manuel technique_).
    En particulier, les choix de conception devront Ãªtre documentÃ©s.
* Vous utiliserez `git` en effectuant des commits rÃ©guliers dÃ©crits par des messages informatifs.
L'usage des branches est Ã©galement exigÃ©, attestant ainsi de votre collaboration au sein du groupe.
La version finale de votre projet devra se trouver dans la branche `main`.
* La version de Java Ã  utiliser est la https://adoptium.net/[version 17] (ou plus rÃ©cente).
* Le _build_ sera assurÃ© par _Maven_ et plus prÃ©cisÃ©ment _Maven wrapper_ (dÃ©jÃ  intÃ©grÃ© dans le projet).
Aucune manipulation en dehors de Maven ne devra Ãªtre nÃ©cessaire pour la compilation.
* Le projet devra respecter les rÃ¨gles de codage Google (vÃ©rification par `checkstyle` dÃ©jÃ  intÃ©grÃ© dans le projet).
* Des tests unitaires https://junit.org/junit5/docs/current/user-guide/[JUnit 5] devront Ãªtre disponibles pour une part significative des mÃ©thodes dÃ©veloppÃ©es.
* Un outil de https://fr.wikipedia.org/wiki/Couverture_de_code[_Code Coverage_] devra Ãªtre intÃ©grÃ© au _build_
* Les fonctionnalitÃ©s du langage Java devront Ãªtre utilisÃ©es au mieux (POO, exceptions, librairie de collections, I/O, â€¦).
* L'application devra pouvoir Ãªtre exÃ©cutÃ©e Ã  partir d'un `jar` incluant toutes les dÃ©pendances.
* L'application fonctionnera dans un terminal (pas d'interface graphique).

== Description fonctionnelle
L'application doit permettre de jouer de 0 Ã  4 joueurs humains, i.e. de zÃ©ro Ã  quatre adversaires virtuels dÃ©nommÃ©s dans la suite _Joueurs Virtuels_ (**JV**).
Chaque JV joue grace Ã  un _Moteur de Jeu_ (**MJ**) modÃ©lisÃ© par une classe de votre programme.
Un MJ peut appliquer une stratÃ©gie basique, ou bien jouer Ã  l'aide de stratÃ©gies plus sophistiquÃ©es.
Bien entendu, l'application doit gÃ©rer l'enchaÃ®nement des manches{empty}footnote:[Une manche se termine quand il ne reste des cartes qu'Ã  un seul joueur (cf. la rÃ¨gle du jeu).] et les dÃ©comptes des points jusqu'Ã  la fin du jeu{empty}footnote:[Le jeu se termine lorsqu'un joueur atteint ou dÃ©passe un certain nombre de points (500 en gÃ©nÃ©ral).].

=== Interface de l'application
L'interface textuelle devra

* visualiser les actions de chaque joueur par des messages textuels clairs et concis (par exemple, "JV1: ğŸ‚®, ğŸ‚¾, ğŸƒ, ğŸƒˆ, ğŸƒ˜" ou "JV1: K(SHD), 8(DC)").
* afficher chaque joueur et ses messages dans une couleur distincte.
* valider les saisies des joueurs humains
  - pour saisir une combinaison, le joueur utilisera une syntaxe du type `<Valeur>(<couleur1><couleur2>)` (par exemple "K(SHD), Q(DC)").
* afficher le nombre de cartes de chaque joueur, mais pas les valeurs de ses cartes (sauf en mode dÃ©bogage).
* toujours afficher les cartes ordonnÃ©es du plus fort au plus faible et pique (_Spade_) avant cÅ“ur (_Heart_) avant carreau (_Diamond_) avant trÃ¨fle (_Club_).
* afficher un message clair pour les actions effectuÃ©es par l'application.

=== Contraintes Ã  respecter
* Un joueur peu dÃ©cider d'abandonner. 
C'est un Ã©vÃ©nement rare (surtout chez les JV), mais possible.
* L'historique d'une partie sera mÃ©morisÃ©e dans une collection stockÃ©e dans un fichier.
  - il sera donc possible de rejouer une partie ou d'afficher le dÃ©roulÃ© d'une partie
* Vous devez implÃ©menter un MJ appliquant une stratÃ©gie triviale.
Le MJ se dÃ©barrasse de ses cartes au fur et Ã  mesure sans aucun assemblage.
* Vous devez Ã©galement implÃ©menter au moins un MJ qui joue de maniÃ¨re plus sophistiquÃ©e.
* Un mode dÃ©bogage permettra de jouer Ã  jeux ouverts.
* Le MJ associÃ© Ã  chaque JV doit pouvoir Ãªtre modifiÃ©.
* Une interface de configuration permettra de modifier les paramÃ¨tres du jeu (variantes, nombre de points pour gagner, MJ Ã  utiliser, â€¦)

== RÃ©fÃ©rences
* https://github.com/lyudaio/jcards[jCards] - A Lightweight Java Library for manipulating Playing Cards
* http://fusesource.github.io/jansi/[JAnsi] - Gestion des couleur dans un terminal
* https://github.com/jline/jline3[JLine] - Gestion des saisies

== Manuel utilisateur (Ã  complÃ©ter)

> Comment configurer et dÃ©marrer une partie ?
> Quelle syntaxe utiliser pour jouer une combinaison de carte ?
> Quelles autres actions sont disponibles ?
> Quelles stratÃ©gies utilisent les diffÃ©rents MJ ?
> Quelles Ã©volutions peut-on envisager ?

== Manuel technique
=== Compiler le projet
.Sous Linux
----
$ JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64/ ./mvnw package
----

.Sous Windows
----
> mvnw.cmd package
----

=== ExÃ©cuter l'application
----
$ java -jar target/zhengfen-1.0.jar
----

.Ã€ complÃ©ter
--
> Comment consulter le rapport de couverture de code par les tests ?
> Quelles bibliothÃ¨ques ont Ã©tÃ© utilisÃ©es et pourquoi ?
> Quel est le rÃ´le des diffÃ©rentes classes ?
> Quels choix de conception (principes, patterns, â€¦) ont Ã©tÃ© faits et pourquoi ?
> Quels traitements sont rÃ©alisÃ©s pour gÃ©rer une commande saisie par l'utilisateur ? Donnez un exemple.
> Quelles amÃ©liorations peut-on envisager ?
--
